#!/usr/bin/env python3
# SPDX-License-Identifier: MIT
# Copyright (c) 2024-2025 Adar Bahar  # cspell:disable-line
"""
Ports Manager - A terminal-based tool for monitoring network ports and processes.
Optimized version with improved performance and code structure.
"""
import curses
import json
import os
import re
import shlex
import shutil
import subprocess
import sys
import time
import urllib.request
import urllib.error

from dataclasses import dataclass, field
from typing import Dict, List, Set, Optional, Any, Tuple

# =========================
# Configuration
# =========================
VERSION = "2.1.0"  # Current version (testing auto-update)
GITHUB_REPO = "AdarBahar/ports"  # GitHub repository  # cspell:disable-line
GITHUB_API_URL = f"https://api.github.com/repos/{GITHUB_REPO}/releases/latest"
GITHUB_RAW_URL = f"https://raw.githubusercontent.com/{GITHUB_REPO}/main/ports"

LO_PORT, HI_PORT = 3000, 9999
REFRESH_SECS_DEFAULT = 2.0
COMMAND_TIMEOUT_SECS = 10.0  # Timeout for external commands
ALIASES_PATH = os.path.expanduser("~/.ports_aliases.json")

# UI Configuration
MAX_ALIAS_LENGTH = 24  # Maximum characters for alias names
ALIAS_COLUMN_WIDTH = 24  # Display width for alias column

# Regex patterns (compiled once for performance)
LSOF_FIELDS = ["COMMAND", "PID", "USER", "FD", "TYPE", "DEVICE", "SIZE/OFF", "NODE", "NAME"]
NAME_RE = re.compile(r"^(?P<local>\S+?)(?:->(?P<remote>\S+))?(?: \((?P<state>[A-Z]+)\))?$")

# Docker port mapping regex - matches patterns like:
# "0.0.0.0:8080->8080/tcp" or "*:3000->3000/tcp" or "[::]:5432->5432/tcp"
# Groups: hostip (optional), hport (host port), cport (container port), proto (protocol)  # cspell:disable-line
_HOST_IP_PATTERN = r"(?P<hostip>\*|[\[\]0-9a-fA-F:\.]+):"  # Host IP (IPv4/IPv6/wildcard)  # cspell:disable-line
_HOST_PORT_PATTERN = r"(?P<hport>\d+)"                     # Host port number  # cspell:disable-line
_CONTAINER_PORT_PATTERN = r"(?P<cport>\d+(?:-\d+)?)"       # Container port (single or range)  # cspell:disable-line
_PROTOCOL_PATTERN = r"(?P<proto>\w+)"                      # Protocol (tcp/udp)

PORT_MAP_RE = re.compile(
    rf"(?:{_HOST_IP_PATTERN})?{_HOST_PORT_PATTERN}\s*->\s*{_CONTAINER_PORT_PATTERN}/{_PROTOCOL_PATTERN}"
)
DOCKER_PS_FMT = "{{.ID}} {{.Names}} {{.Image}} {{.Ports}}"

# Built-in friendly names for common processes
BUILTIN_FRIENDLY = {
    "httpd": "Web server",
    "apache2": "Web server",
    "nginx": "Web server",
    "caddy": "Web server",
    "node": "Node.js",
    "nodejs": "Node.js",
    "python": "Python app",
    "gunicorn": "Gunicorn",
    "uvicorn": "Uvicorn",
    "php-fpm": "PHP-FPM",
    "mysqld": "MySQL",  # cspell:disable-line
    "mysql": "MySQL",
    "postgres": "PostgreSQL",
    "postgresql": "PostgreSQL",
    "redis-server": "Redis",
    "mongod": "MongoDB",
    "java": "Java app",
    "docker-proxy": "Docker published port",
    "kafka": "Kafka",
    "zookeeper": "ZooKeeper",
    "ssh": "SSH server",
}

# =========================
# Data Classes
# =========================
@dataclass
class PortEntry:
    """Represents a single port entry with all its attributes."""
    proc: str = ""
    pid: str = ""
    user: str = ""
    port: int = 0
    state: str = ""
    local: str = ""
    remote: str = ""
    container: str = ""
    image: str = ""
    cport: str = ""  # cspell:disable-line
    source: str = "host"

@dataclass
class AggregatedPort:
    """Represents aggregated data for a port in unique mode."""
    port: int
    states: Set[str] = field(default_factory=set)
    procs: List[str] = field(default_factory=list)  # cspell:disable-line
    containers: List[str] = field(default_factory=list)
    images: List[str] = field(default_factory=list)
    locals: Set[str] = field(default_factory=set)
    remotes: Set[str] = field(default_factory=set)
    cports: Set[str] = field(default_factory=set)  # cspell:disable-line
    has_host_listener: bool = False
    has_docker: bool = False

# =========================
# Version Management
# =========================
def parse_version(version_str: str) -> Tuple[int, int, int]:
    """Parse version string into tuple for comparison."""
    try:
        # Remove 'v' prefix if present and split by dots
        clean_version = version_str.lstrip('v')
        parts = clean_version.split('.')
        return (int(parts[0]), int(parts[1]), int(parts[2]) if len(parts) > 2 else 0)
    except (ValueError, IndexError):
        return (0, 0, 0)

def check_for_updates() -> Optional[str]:
    """Check GitHub for newer version. Returns new version string if available."""
    try:
        with urllib.request.urlopen(GITHUB_API_URL, timeout=5) as response:
            data = json.loads(response.read().decode())
            latest_version = data.get('tag_name', '').lstrip('v')

            current = parse_version(VERSION)
            latest = parse_version(latest_version)

            if latest > current:
                return latest_version
    except (urllib.error.URLError, json.JSONDecodeError, KeyError):
        pass  # Silently fail - don't interrupt user experience

    return None

def download_update() -> bool:
    """Download the latest version from GitHub. Returns True if successful."""
    # Get current script path
    current_script = os.path.abspath(__file__)
    backup_script = current_script + ".backup"

    try:
        # Create backup of current version
        shutil.copy2(current_script, backup_script)

        # Download new version
        with urllib.request.urlopen(GITHUB_RAW_URL, timeout=30) as response:
            new_content = response.read()

        # Write new version
        with open(current_script, 'wb') as f:
            f.write(new_content)

        # Make executable
        os.chmod(current_script, 0o755)

        return True
    except (urllib.error.URLError, OSError, IOError):
        # Restore backup if download failed
        try:
            if os.path.exists(backup_script):
                shutil.copy2(backup_script, current_script)
        except (OSError, IOError):
            pass
        return False

def restart_application() -> None:
    """Restart the application with the same arguments."""
    try:
        # Clean up backup file
        backup_script = os.path.abspath(__file__) + ".backup"
        if os.path.exists(backup_script):
            os.remove(backup_script)
    except OSError:
        pass

    # Restart with same arguments
    os.execv(sys.executable, [sys.executable] + sys.argv)  # cspell:disable-line

def show_update_prompt(screen, new_version: str) -> bool:
    """Show update prompt and return True if user wants to update."""
    try:
        height, width = screen.getmaxyx()  # cspell:disable-line
    except curses.error:
        height, width = 24, 80

    # Clear screen and show update message
    screen.clear()

    update_text = [
        "ðŸš€ UPDATE AVAILABLE",
        "",
        f"Current version: {VERSION}",
        f"Latest version:  {new_version}",
        "",
        "A newer version of Ports Manager is available!",
        "",
        "Press 'u' to update automatically",
        "Press any other key to continue with current version",
        "",
        "The update will:",
        "â€¢ Download the latest version from GitHub",
        "â€¢ Backup your current version",
        "â€¢ Restart the application automatically",
    ]

    # Center the text
    start_y = max(1, (height - len(update_text)) // 2)

    for i, line in enumerate(update_text):
        y = start_y + i
        if y < height - 1:
            x = max(0, (width - len(line)) // 2)
            safe_addnstr(screen, y, x, line, width - x)  # cspell:disable-line

    screen.refresh()

    # Wait for user input
    while True:
        try:
            key = screen.getch()  # cspell:disable-line
            if key == ord('u') or key == ord('U'):
                return True
            elif key != -1:  # Any other key
                return False
        except curses.error:
            return False

# =========================
# Utility Functions
# =========================
def run_command(cmd: str, timeout: Optional[float] = None) -> str:
    """Execute a shell command and return output, or empty string on error."""
    if timeout is None:
        timeout = COMMAND_TIMEOUT_SECS

    try:
        return subprocess.check_output(
            shlex.split(cmd),
            stderr=subprocess.DEVNULL,
            text=True,
            timeout=timeout
        )
    except (subprocess.CalledProcessError, subprocess.TimeoutExpired, OSError):
        return ""

def _default_aliases() -> Dict[str, Dict[str, str]]:
    """Return default alias structure."""
    return {"per_entry": {}, "per_proc": {}}

def ensure_alias_file_exists() -> Dict[str, Dict[str, str]]:
    """
    Ensure ~/.ports_aliases.json exists and is valid.
    Creates or repairs the file if needed. Never raises exceptions.
    """
    data: Optional[Dict[str, Any]] = None

    if os.path.exists(ALIASES_PATH):
        try:
            with open(ALIASES_PATH, "r", encoding="utf-8") as f:
                data = json.load(f)
        except (json.JSONDecodeError, OSError):
            # Corrupt file - backup and recreate
            try:
                os.replace(ALIASES_PATH, f"{ALIASES_PATH}.bak")
            except OSError:
                pass
            data = None

    if not isinstance(data, dict):
        data = _default_aliases()

    # Ensure required keys exist
    for key in ["per_entry", "per_proc"]:
        if key not in data or not isinstance(data[key], dict):
            data[key] = {}

    # Write normalized file
    try:
        with open(ALIASES_PATH, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
    except OSError:
        pass

    return data

def load_aliases() -> Dict[str, Dict[str, str]]:
    """Load aliases from file."""
    return ensure_alias_file_exists()

def save_aliases(aliases: Dict[str, Dict[str, str]]) -> None:
    """Save aliases to file with validation."""
    # Validate structure
    for key in ["per_entry", "per_proc"]:
        if key not in aliases or not isinstance(aliases[key], dict):
            aliases[key] = {}

    try:
        with open(ALIASES_PATH, "w", encoding="utf-8") as f:
            json.dump(aliases, f, indent=2, ensure_ascii=False)
    except OSError:
        pass

def per_entry_key_detail(entry: PortEntry) -> str:
    """Generate key for per-entry alias in detail mode."""
    return f"detail:{entry.proc}|{entry.pid}|{entry.port}"

def per_entry_key_unique(port: int) -> str:
    """Generate key for per-entry alias in unique mode."""
    return f"unique:{port}"

def truncate_alias_for_display(alias: str) -> str:
    """Truncate alias for display if it's too long."""
    if len(alias) <= ALIAS_COLUMN_WIDTH:
        return alias
    return alias[:ALIAS_COLUMN_WIDTH-1] + "â€¦"

def resolve_alias(entry: PortEntry, unique_mode: bool, aliases: Dict[str, Dict[str, str]]) -> str:
    """
    Resolve alias for a port entry with priority:
    1) Per-entry alias (mode-specific)
    2) Per-process alias (user-defined)
    3) Built-in friendly name
    """
    # Check per-entry aliases first
    if unique_mode:
        key = per_entry_key_unique(entry.port)
    else:
        key = per_entry_key_detail(entry)

    if key in aliases["per_entry"]:
        return truncate_alias_for_display(aliases["per_entry"][key])

    # Check per-process aliases
    proc = entry.proc.strip()
    if proc and proc in aliases["per_proc"]:
        return truncate_alias_for_display(aliases["per_proc"][proc])

    # Check built-in friendly names
    if proc and proc in BUILTIN_FRIENDLY:
        return truncate_alias_for_display(BUILTIN_FRIENDLY[proc])

    return ""

def resolve_alias_for_unique_row(row: Dict[str, Any], aliases: Dict[str, Dict[str, str]]) -> str:
    """Resolve alias for aggregated unique mode row."""
    # Check per-entry alias for this port
    port = row.get("port", 0)
    key = per_entry_key_unique(port)
    if key in aliases["per_entry"]:
        return truncate_alias_for_display(aliases["per_entry"][key])

    # Try to get process name from summary
    proc_summary = row.get("proc_summary", "")
    if proc_summary:
        first_proc = proc_summary.split(",")[0].strip()
        if first_proc in aliases["per_proc"]:
            return truncate_alias_for_display(aliases["per_proc"][first_proc])
        if first_proc in BUILTIN_FRIENDLY:
            return truncate_alias_for_display(BUILTIN_FRIENDLY[first_proc])

    return ""

# =========================
# lsof Processing
# =========================
def run_lsof(only_listen: bool) -> List[str]:
    """Run lsof command and return output lines."""
    cmd = f"lsof -nP -iTCP:{LO_PORT}-{HI_PORT}"
    if only_listen:
        cmd += " -sTCP:LISTEN"
    output = run_command(cmd)
    return output.splitlines() if output else []

def extract_port_from_address(address: str) -> Optional[int]:
    """Extract port number from address string (handles IPv4 and IPv6)."""
    try:
        if address.startswith('['):  # IPv6 like [::1]:5173
            return int(address.rsplit(':', 1)[1])
        elif ':' in address:  # IPv4 like 127.0.0.1:5173
            return int(address.rsplit(':', 1)[1])
    except (ValueError, IndexError):
        pass
    return None

def parse_lsof(lines: List[str]) -> List[PortEntry]:
    """Parse lsof output into PortEntry objects."""
    # Find header line
    header_idx = None
    for i, line in enumerate(lines):
        if line.strip().startswith("COMMAND") and "NAME" in line:
            header_idx = i
            break

    if header_idx is None:
        return []

    entries = []
    for line in lines[header_idx + 1:]:
        line = line.strip()
        if not line:
            continue

        # Split into fields (last field may contain spaces)
        parts = line.split(None, len(LSOF_FIELDS) - 1)
        if len(parts) < len(LSOF_FIELDS):
            continue

        row = dict(zip(LSOF_FIELDS, parts))

        # Parse the NAME field
        match = NAME_RE.match(row["NAME"])
        if not match:
            continue

        local = match.group("local") or ""
        remote = match.group("remote") or ""
        state = match.group("state") or ""

        # Extract port number
        port = extract_port_from_address(local)
        if port is None:
            continue

        entry = PortEntry(
            proc=row["COMMAND"],
            pid=row["PID"],
            user=row["USER"],
            port=port,
            state=state,
            local=local,
            remote=remote,
            source="host"
        )
        entries.append(entry)

    # Sort by port, then by PID
    entries.sort(key=lambda e: (e.port, int(e.pid) if e.pid.isdigit() else 0))
    return entries

# =========================
# Docker Processing
# =========================
@dataclass
class DockerInfo:
    """Docker container port mapping information."""
    container: str
    image: str
    cport: str  # cspell:disable-line
    proto: str
    container_id: str

def docker_port_map() -> Tuple[Dict[int, List[DockerInfo]], List[PortEntry]]:
    """
    Get Docker port mappings and return host port map and docker-only entries.
    Returns: (host_port_map, docker_only_entries)
    """
    if not shutil.which("docker"):
        return {}, []

    output = run_command(f"docker ps --format '{DOCKER_PS_FMT}'")
    if not output:
        return {}, []

    host_map: Dict[int, List[DockerInfo]] = {}
    docker_entries: List[PortEntry] = []

    for line in output.splitlines():
        parts = line.split(" ", 3)
        if len(parts) < 4:
            continue

        container_id, name, image, ports_str = parts
        if not ports_str:
            continue

        # Parse port mappings
        for segment in ports_str.split(","):
            segment = segment.strip()
            match = PORT_MAP_RE.search(segment)
            if not match:
                continue

            try:
                host_port = int(match.group("hport"))  # cspell:disable-line
                if not (LO_PORT <= host_port <= HI_PORT):
                    continue

                container_port = match.group("cport")  # cspell:disable-line
                protocol = match.group("proto")

                # Create Docker info
                docker_info = DockerInfo(
                    container=name,
                    image=image,
                    cport=container_port,  # cspell:disable-line
                    proto=protocol,
                    container_id=container_id
                )

                # Add to host map
                host_map.setdefault(host_port, []).append(docker_info)

                # Create docker entry
                docker_entry = PortEntry(
                    proc="docker-proxy",
                    port=host_port,
                    state="PUBLISHED",
                    local=f"0.0.0.0:{host_port}",
                    container=name,
                    image=image,
                    cport=f"{container_port}/{protocol}",  # cspell:disable-line
                    source="docker"
                )
                docker_entries.append(docker_entry)

            except (ValueError, KeyError):
                continue

    # Sort docker entries
    docker_entries.sort(key=lambda e: (e.port, e.container))
    return host_map, docker_entries

# =========================
# Data Merging and Aggregation
# =========================
def merge_rows(
    host_entries: List[PortEntry],
    docker_host_map: Dict[int, List[DockerInfo]],
    docker_only_entries: List[PortEntry],
    show_docker_only: bool
) -> List[PortEntry]:
    """Merge host entries with Docker information."""
    merged: List[PortEntry] = []

    # Merge host entries with Docker info
    for entry in host_entries:
        docker_infos = docker_host_map.get(entry.port, [])
        if docker_infos:
            # Create separate entries for each Docker mapping
            for docker_info in docker_infos:
                merged_entry = PortEntry(
                    proc=entry.proc,
                    pid=entry.pid,
                    user=entry.user,
                    port=entry.port,
                    state=entry.state,
                    local=entry.local,
                    remote=entry.remote,
                    container=docker_info.container,
                    image=docker_info.image,
                    cport=f"{docker_info.cport}/{docker_info.proto}",  # cspell:disable-line
                    source=entry.source
                )
                merged.append(merged_entry)
        else:
            merged.append(entry)

    # Add Docker-only entries if requested
    if show_docker_only:
        host_ports = {entry.port for entry in merged}
        for docker_entry in docker_only_entries:
            if docker_entry.port not in host_ports:
                merged.append(docker_entry)

    # Sort by port, container, then process
    merged.sort(key=lambda e: (e.port, e.container, e.proc))
    return merged

def unique_keep_order(sequence: List[str]) -> List[str]:
    """Remove duplicates while preserving order."""
    seen: Set[str] = set()
    result = []
    for item in sequence:
        if item and item not in seen:
            seen.add(item)
            result.append(item)
    return result

def summarize_list(items: List[str], max_items: int = 3) -> str:
    """Summarize a list with truncation if too long."""
    if not items:
        return ""
    if len(items) <= max_items:
        return ", ".join(items)
    return ", ".join(items[:max_items]) + f" +{len(items) - max_items} more"

def aggregate_unique_ports(entries: List[PortEntry]) -> List[Dict[str, Any]]:
    """Aggregate port entries by port number for unique mode display."""
    by_port: Dict[int, AggregatedPort] = {}

    for entry in entries:
        if entry.port not in by_port:
            by_port[entry.port] = AggregatedPort(port=entry.port)

        agg = by_port[entry.port]

        # Aggregate data
        if entry.state:
            agg.states.add(entry.state)
        if entry.proc:
            agg.procs.append(entry.proc)  # cspell:disable-line
        if entry.container:
            agg.containers.append(entry.container)
        if entry.image:
            agg.images.append(entry.image)
        if entry.local:
            agg.locals.add(entry.local)
        if entry.remote:
            agg.remotes.add(entry.remote)
        if entry.cport:  # cspell:disable-line
            agg.cports.add(entry.cport)  # cspell:disable-line

        # Track source types
        if entry.source == "host":
            agg.has_host_listener = True
        elif entry.source == "docker":
            agg.has_docker = True

    # Convert to output format
    result = []
    for port_num, agg in by_port.items():
        # Determine primary state
        if "LISTEN" in agg.states:
            state = "LISTEN"
        elif "PUBLISHED" in agg.states:
            state = "PUBLISHED"
        elif "ESTABLISHED" in agg.states:
            state = "ESTABLISHED"
        else:
            state = ",".join(sorted(agg.states)) if agg.states else ""

        # Create summaries
        procs_unique = unique_keep_order(agg.procs)  # cspell:disable-line
        containers_unique = unique_keep_order(agg.containers)
        images_unique = unique_keep_order(agg.images)

        # Create note with local address and container ports
        local_hint = next(iter(agg.locals), f"*:{port_num}")
        cports_hint = summarize_list(sorted(agg.cports)) if agg.cports else ""  # cspell:disable-line
        note = local_hint
        if cports_hint:  # cspell:disable-line
            note += f"  [{cports_hint}]"  # cspell:disable-line

        # Determine source
        if agg.has_host_listener and agg.has_docker:
            source = "mixed"
        elif agg.has_docker:
            source = "docker"
        else:
            source = "host"

        result.append({
            "port": port_num,
            "state": state,
            "proc_summary": summarize_list(procs_unique),  # cspell:disable-line
            "container_summary": summarize_list(containers_unique),
            "image_summary": summarize_list(images_unique),
            "note": note,
            "source": source,
        })

    result.sort(key=lambda r: r["port"])
    return result

# =========================
# UI Helper Functions
# =========================
def safe_addnstr(screen, y: int, x: int, text: str, max_width: int) -> None:  # cspell:disable-line
    """Safely add string to screen with bounds checking."""
    try:
        height, width = screen.getmaxyx()  # cspell:disable-line
        if y < 0 or y >= height or x < 0 or x >= width:
            return

        available_width = max(0, min(max_width, width - x))
        if available_width <= 0:
            return

        screen.addnstr(y, x, text[:available_width], available_width)  # cspell:disable-line
    except curses.error:
        # Ignore curses errors (e.g., writing to bottom-right corner)
        pass

def show_message(screen, message: str, wait_for_key: bool = True) -> None:
    """Display a message at the bottom of the screen."""
    try:
        height, width = screen.getmaxyx()  # cspell:disable-line
    except curses.error:
        height, width = 24, 80

    message_line = height - 1

    try:
        screen.move(message_line, 0)
        screen.clrtoeol()  # cspell:disable-line
        safe_addnstr(screen, message_line, 0, message, width - 1)  # cspell:disable-line
        screen.refresh()

        if wait_for_key:
            # Wait for any key press
            screen.getch()  # cspell:disable-line
    except curses.error:
        pass

def get_user_input(screen, prompt: str) -> str:
    """Get user input from the bottom line of the screen with ESC support."""
    # Turn OFF echo to prevent double characters
    curses.noecho()  # cspell:disable-line
    try:
        # Handle potential terminal resize during input
        try:
            height, width = screen.getmaxyx()  # cspell:disable-line
        except curses.error:
            # Terminal might be resizing, use safe defaults
            height, width = 24, 80

        input_line = height - 1

        # Clear the line and show prompt
        try:
            screen.move(input_line, 0)
            screen.clrtoeol()  # cspell:disable-line
            safe_addnstr(screen, input_line, 0, prompt, width - 1)  # cspell:disable-line
            screen.refresh()
        except curses.error:
            # Handle resize during drawing
            pass

        # Get user input with ESC detection
        input_text = ""
        cursor_pos = len(prompt)

        try:
            screen.move(input_line, cursor_pos)
            while True:
                key = screen.getch()  # cspell:disable-line

                if key == 27:  # ESC key
                    return ""  # Return empty string to indicate cancellation
                elif key == ord('\n') or key == ord('\r') or key == 10:
                    break  # Enter pressed, return current input
                elif key == curses.KEY_BACKSPACE or key == 127 or key == 8:
                    # Backspace - remove character from input and screen
                    if input_text:
                        input_text = input_text[:-1]
                        cursor_pos -= 1
                        try:
                            # Move cursor back and clear the character
                            screen.move(input_line, cursor_pos)
                            screen.addch(ord(' '))  # Replace with space  # cspell:disable-line
                            screen.move(input_line, cursor_pos)  # Move cursor back
                            screen.refresh()
                        except curses.error:
                            pass
                elif 32 <= key <= 126:  # Printable ASCII characters
                    # Use different limits based on context (alias vs general input)
                    max_len = MAX_ALIAS_LENGTH if "alias" in prompt.lower() else 100
                    if len(input_text) < max_len:
                        input_text += chr(key)
                        try:
                            screen.addch(key)  # cspell:disable-line
                            screen.refresh()
                            cursor_pos += 1
                        except curses.error:
                            pass
                    # If at limit, ignore the keypress (no visual feedback for rejected chars)

        except curses.error:
            pass

        return input_text.strip()
    finally:
        # Keep echo OFF since we're handling it manually
        pass

def draw_header(screen, only_listen: bool, refresh_secs: float, show_docker_only: bool, unique_mode: bool) -> None:
    """Draw the application header with title and column headers."""
    height, width = screen.getmaxyx()  # cspell:disable-line
    mode = "UNIQUE" if unique_mode else "DETAIL"

    # Create title line
    title = (
        f"Ports Manager by Adar Bahar v{VERSION} | https://github.com/AdarBahar/ports | TCP {LO_PORT}-{HI_PORT} | "  # cspell:disable-line
        f"[u] {mode} | [l] LISTEN: {'ON' if only_listen else 'OFF'} | "
        f"[d] Docker: {'ON' if show_docker_only else 'OFF'} | "
        f"[+/-] {refresh_secs:.1f}s | [?] help | [q] quit"
    )

    # Draw title with bold formatting
    try:
        screen.attron(curses.A_BOLD)  # cspell:disable-line
        safe_addnstr(screen, 0, 0, title.ljust(width), width)  # cspell:disable-line
        screen.attroff(curses.A_BOLD)  # cspell:disable-line
    except curses.error:
        pass

    # Draw horizontal line
    if height >= 2:
        try:
            screen.hline(1, 0, curses.ACS_HLINE, width)  # cspell:disable-line
        except curses.error:
            pass

    # Draw column headers
    if unique_mode:
        header = (
            f"{'#':>3} {'PORT':>6}  {'STATE':<12} {'PROCESSES':<26} "
            f"{'CONTAINERS':<22} {'IMAGES':<20} {'ALIAS':<{ALIAS_COLUMN_WIDTH}} {'LOCAL / CONTAINER PORTS'}"
        )
    else:
        header = (
            f"{'#':>3} {'PORT':>6}  {'STATE':<12} {'PID':>7}  {'USER':<10} "
            f"{'PROCESS':<14} {'CONTAINER':<16} {'IMAGE':<16} {'ALIAS':<{ALIAS_COLUMN_WIDTH}} "
            f"{'LOCAL â†’ REMOTE / CONTAINER PORT'}"
        )

    safe_addnstr(screen, 2, 0, header.ljust(width), width)  # cspell:disable-line

    # Draw second horizontal line
    if height >= 4:
        try:
            screen.hline(3, 0, curses.ACS_HLINE, width)  # cspell:disable-line
        except curses.error:
            pass

def get_state_color_pair(state: str) -> int:
    """Get color pair number for connection state."""
    if state in ("LISTEN", "PUBLISHED"):
        return 2  # Green
    elif state == "ESTABLISHED":
        return 3  # Cyan
    else:
        return 1  # Default

def draw_rows_detail(screen, entries: List[PortEntry], aliases: Dict[str, Dict[str, str]], start_line: int = 4) -> None:
    """Draw port entries in detail mode."""
    height, width = screen.getmaxyx()  # cspell:disable-line
    if height <= start_line + 1:
        return

    max_rows = max(0, height - start_line - 2)

    for i in range(max_rows):
        y = start_line + i

        # Clear line if no more entries
        if i >= len(entries):
            safe_addnstr(screen, y, 0, " " * (width - 1), width - 1)  # cspell:disable-line
            continue

        entry = entries[i]
        alias = resolve_alias(entry, unique_mode=False, aliases=aliases)

        # Format the row
        left_part = (
            f"{i+1:>3} {entry.port:>6}  {entry.state:<12} {entry.pid:>7}  {entry.user:<10} "
            f"{entry.proc:<14} {entry.container:<16} {entry.image:<16} {alias:<{ALIAS_COLUMN_WIDTH}} "
        )

        right_part = entry.local
        if entry.remote:
            right_part += f" â†’ {entry.remote}"
        if entry.cport:  # cspell:disable-line
            right_part += f"   [{entry.cport}]"  # cspell:disable-line

        # Apply color based on state
        color_pair = get_state_color_pair(entry.state)
        try:
            screen.attron(curses.color_pair(color_pair))  # cspell:disable-line
            safe_addnstr(screen, y, 0, left_part + right_part, width - 1)  # cspell:disable-line
            screen.attroff(curses.color_pair(color_pair))  # cspell:disable-line
        except curses.error:
            pass

def draw_rows_unique(screen, rows: List[Dict[str, Any]], aliases: Dict[str, Dict[str, str]], start_line: int = 4) -> None:
    """Draw aggregated port entries in unique mode."""
    height, width = screen.getmaxyx()  # cspell:disable-line
    if height <= start_line + 1:
        return

    max_rows = max(0, height - start_line - 2)

    for i in range(max_rows):
        y = start_line + i

        # Clear line if no more rows
        if i >= len(rows):
            safe_addnstr(screen, y, 0, " " * (width - 1), width - 1)  # cspell:disable-line
            continue

        row = rows[i]
        alias = resolve_alias_for_unique_row(row, aliases)
        state = row.get("state", "")

        # Format the row
        left_part = (
            f"{i+1:>3} {row['port']:>6}  {state:<12} {row.get('proc_summary',''):<26} "
            f"{row.get('container_summary',''):<22} {row.get('image_summary',''):<20} {alias:<{ALIAS_COLUMN_WIDTH}} "
        )
        right_part = row.get("note", "")

        # Apply color based on state
        color_pair = get_state_color_pair(state)
        try:
            screen.attron(curses.color_pair(color_pair))  # cspell:disable-line
            safe_addnstr(screen, y, 0, left_part + right_part, width - 1)  # cspell:disable-line
            screen.attroff(curses.color_pair(color_pair))  # cspell:disable-line
        except curses.error:
            pass

def draw_help(screen) -> None:
    """Display help screen with all available commands and information."""
    screen.clear()
    _, width = screen.getmaxyx()  # cspell:disable-line

    help_text = [
        "=== Ports Manager Help ===",
        "",
        "Hotkeys:",
        "  q       - quit application",
        "  u       - toggle unique/detail mode",
        "  l       - toggle LISTEN-only filter",
        "  d       - toggle docker-only rows",
        "  + / -   - change refresh speed",
        "  a       - add/edit alias for a row (per-entry)",
        "  x       - delete per-entry alias",
        "  g       - set/edit global per-process alias",
        "  ?       - show this help",
        "  ESC     - close this help screen",
        "",
        "Alias Types:",
        "  â€¢ Per-entry alias (a/x): tied to one specific row",
        "      - Detail mode: process + PID + port",
        "      - Unique mode: port number only",
        "  â€¢ Per-process alias (g): tied to process name",
        "      - Applies to ALL rows with that process",
        "      - Good for permanent names (e.g. mysqld â†’ MySQL)",  # cspell:disable-line
        "",
        "Display Modes:",
        "  â€¢ Unique mode: aggregates entries by port number",
        "  â€¢ Detail mode: shows every process separately",
        "  â€¢ LISTEN filter: shows only listening sockets",
        "  â€¢ Docker-only: includes docker-published ports",
        "",
        "Tips:",
        "  â€¢ Use 'sudo' for full process visibility",
        "  â€¢ Aliases are saved automatically",
        "  â€¢ Press ESC or any key to return to main view"
    ]

    for i, line in enumerate(help_text):
        safe_addnstr(screen, i + 1, 2, line, width - 4)  # cspell:disable-line

    screen.refresh()

    # Wait for ESC key or any other key to close
    while True:
        try:
            key = screen.getch()  # cspell:disable-line
            if key == 27:  # ESC key
                break
            elif key != -1:  # Any other key (except no-key)
                break
        except curses.error:
            break

def draw_footer(screen) -> None:
    """Draw footer with quick reference and tips."""
    height, width = screen.getmaxyx()  # cspell:disable-line
    if height < 6:
        return

    # Draw horizontal line
    try:
        screen.hline(height - 2, 0, curses.ACS_HLINE, width)  # cspell:disable-line
    except curses.error:
        pass

    # Footer message
    footer_msg = (
        "Keys: [q] quit | [u] mode | [l] LISTEN | [d] docker | [+/-] refresh | "
        "[a] alias | [x] delete | [g] process | [?] help | Tip: use sudo for full visibility"
    )
    safe_addnstr(screen, height - 1, 0, footer_msg, width - 1)  # cspell:disable-line

# =========================
# Process Selection for Aliases
# =========================
def choose_proc_for_alias(
    screen,
    unique_mode: bool,
    detail_entries: List[PortEntry],
    unique_rows: List[Dict[str, Any]]
) -> Tuple[str, str]:
    """
    Get process name for per-process alias with validation.
    User can enter a row number or process name directly.
    Returns: (process_name, current_alias)
    """
    current_data = unique_rows if unique_mode else detail_entries
    if not current_data:
        show_message(screen, "No data available. Press any key to continue...")
        return "", ""

    # Get input with validation loop
    error_msg = ""
    while True:
        prompt = f"Row number (1-{len(current_data)}) or process name (ESC to cancel): "
        if error_msg:
            prompt = f"{error_msg} | {prompt}"

        user_input = get_user_input(screen, prompt)

        if not user_input:
            return "", ""

        # Check if input is a row number
        if user_input.isdigit():
            try:
                row_idx = int(user_input) - 1

                if unique_mode:
                    if 0 <= row_idx < len(unique_rows):
                        row = unique_rows[row_idx]
                        proc_summary = row.get("proc_summary", "")
                        if proc_summary:
                            # Get first process from summary
                            first_proc = proc_summary.split(",")[0].strip()
                            return first_proc, ""
                        else:
                            error_msg = f"No process info for row {user_input}"
                            continue
                    else:
                        error_msg = f"Invalid row (must be 1-{len(current_data)})"
                        continue
                else:
                    if 0 <= row_idx < len(detail_entries):
                        entry = detail_entries[row_idx]
                        return entry.proc.strip(), ""
                    else:
                        error_msg = f"Invalid row (must be 1-{len(current_data)})"
                        continue

            except (ValueError, IndexError):
                error_msg = "Invalid row number"
                continue

        # Treat as direct process name input
        proc_name = user_input.strip()
        if proc_name:
            return proc_name, ""
        else:
            error_msg = "Process name cannot be empty"
            continue

# =========================
# Main Application
# =========================
def initialize_curses(screen) -> None:
    """Initialize curses settings and color pairs."""
    curses.curs_set(0)  # Hide cursor  # cspell:disable-line
    curses.use_default_colors()
    curses.init_pair(1, -1, -1)                 # Default
    curses.init_pair(2, curses.COLOR_GREEN, -1) # LISTEN/PUBLISHED
    curses.init_pair(3, curses.COLOR_CYAN, -1)  # ESTABLISHED
    screen.nodelay(True)  # Non-blocking input  # cspell:disable-line

def main(screen) -> None:
    """Main application loop with debouncing for rapid key presses."""
    initialize_curses(screen)

    # Check for updates (non-blocking)
    try:
        new_version = check_for_updates()
        if new_version:
            if show_update_prompt(screen, new_version):
                # User wants to update
                screen.clear()
                screen.addstr(0, 0, "Downloading update...")  # cspell:disable-line
                screen.refresh()

                if download_update():
                    screen.addstr(1, 0, "Update successful! Restarting...")  # cspell:disable-line
                    screen.refresh()
                    time.sleep(1)
                    restart_application()
                else:
                    screen.addstr(1, 0, "Update failed. Continuing with current version...")  # cspell:disable-line
                    screen.refresh()
                    time.sleep(2)
    except Exception:
        # Don't let update check interfere with main functionality
        pass

    # Application state
    refresh_secs = REFRESH_SECS_DEFAULT
    only_listen = True
    show_docker_only = True
    unique_mode = True
    last_refresh = 0.0
    last_key_time = 0.0  # For debouncing rapid key presses
    key_debounce_delay = 0.1  # Minimum time between key actions

    # Load aliases
    aliases = load_aliases()

    # Data storage
    detail_entries: List[PortEntry] = []
    unique_rows: List[Dict[str, Any]] = []

    while True:
        current_time = time.time()

        # Refresh data if needed
        if current_time - last_refresh >= refresh_secs:
            # Get lsof data
            lsof_lines = run_lsof(only_listen)
            host_entries = parse_lsof(lsof_lines)

            # Get Docker data
            docker_host_map, docker_only_entries = docker_port_map()

            # Merge and aggregate
            detail_entries = merge_rows(host_entries, docker_host_map, docker_only_entries, show_docker_only)
            unique_rows = aggregate_unique_ports(detail_entries)

            # Redraw screen
            screen.erase()
            draw_header(screen, only_listen, refresh_secs, show_docker_only, unique_mode)

            if unique_mode:
                draw_rows_unique(screen, unique_rows, aliases)
            else:
                draw_rows_detail(screen, detail_entries, aliases)

            draw_footer(screen)
            screen.refresh()
            last_refresh = current_time

        # Handle input with debouncing
        try:
            key = screen.getch()  # cspell:disable-line
        except curses.error:
            key = -1

        # Process key if enough time has passed (debouncing)
        current_time = time.time()
        if key != -1 and (current_time - last_key_time) >= key_debounce_delay:
            last_key_time = current_time

            if key == ord('q'):
                break
            elif key == ord('l'):
                only_listen = not only_listen
                last_refresh = 0
            elif key == ord('d'):
                show_docker_only = not show_docker_only
                last_refresh = 0
            elif key == ord('u'):
                unique_mode = not unique_mode
                last_refresh = 0
            elif key in (ord('+'), ord('=')):
                refresh_secs = max(0.2, refresh_secs - 0.2)
                last_refresh = 0
            elif key in (ord('-'), ord('_')):
                refresh_secs = min(10.0, refresh_secs + 0.2)
                last_refresh = 0
            elif key == ord('a'):
                # Add/Edit per-entry alias
                handle_add_alias(screen, unique_mode, detail_entries, unique_rows, aliases)
                last_refresh = 0
            elif key == ord('x'):
                # Delete per-entry alias
                handle_delete_alias(screen, unique_mode, detail_entries, unique_rows, aliases)
                last_refresh = 0
            elif key == ord('g'):
                # Set/Edit per-process alias
                handle_process_alias(screen, unique_mode, detail_entries, unique_rows, aliases)
                last_refresh = 0
            elif key == ord('?'):
                draw_help(screen)
                last_refresh = 0

        time.sleep(0.05)

def handle_add_alias(
    screen,
    unique_mode: bool,
    detail_entries: List[PortEntry],
    unique_rows: List[Dict[str, Any]],
    aliases: Dict[str, Dict[str, str]]
) -> None:
    """Handle adding/editing per-entry aliases with validation."""
    current_data = unique_rows if unique_mode else detail_entries
    if not current_data:
        show_message(screen, "No data available. Press any key to continue...")
        return

    # Get row number with validation loop
    error_msg = ""
    while True:
        prompt = f"Row number (1-{len(current_data)}) to alias (ESC to cancel): "
        if error_msg:
            prompt = f"{error_msg} | {prompt}"

        row_input = get_user_input(screen, prompt)

        # Check for ESC key (empty input can mean ESC or just Enter)
        if not row_input:
            return

        try:
            row_idx = int(row_input) - 1
            if 0 <= row_idx < len(current_data):
                break  # Valid input, exit loop
            else:
                error_msg = f"Invalid row (must be 1-{len(current_data)})"
        except ValueError:
            error_msg = "Please enter a number"

    # Get the alias
    if unique_mode:
        row = unique_rows[row_idx]
        existing = resolve_alias_for_unique_row(row, aliases)
        key = per_entry_key_unique(row["port"])
        port_info = f"port {row['port']}"
    else:
        entry = detail_entries[row_idx]
        existing = resolve_alias(entry, unique_mode=False, aliases=aliases)
        key = per_entry_key_detail(entry)
        port_info = f"{entry.proc} (PID {entry.pid}) on port {entry.port}"

    prompt = f"Alias for {port_info} (max {MAX_ALIAS_LENGTH} chars) [{existing}]: " if existing else f"Alias for {port_info} (max {MAX_ALIAS_LENGTH} chars): "
    new_alias = get_user_input(screen, prompt)

    if new_alias:
        aliases["per_entry"][key] = new_alias
        save_aliases(aliases)
        show_message(screen, f"âœ“ Alias '{new_alias}' saved for {port_info}")
    elif existing:
        show_message(screen, f"âœ“ Keeping existing alias '{existing}'")
    else:
        show_message(screen, "âœ“ No alias set")

def handle_delete_alias(
    screen,
    unique_mode: bool,
    detail_entries: List[PortEntry],
    unique_rows: List[Dict[str, Any]],
    aliases: Dict[str, Dict[str, str]]
) -> None:
    """Handle deleting per-entry aliases with validation."""
    current_data = unique_rows if unique_mode else detail_entries
    if not current_data:
        show_message(screen, "No data available. Press any key to continue...")
        return

    # Get row number with validation loop
    error_msg = ""
    while True:
        prompt = f"Row number (1-{len(current_data)}) to clear alias (ESC to cancel): "
        if error_msg:
            prompt = f"{error_msg} | {prompt}"

        row_input = get_user_input(screen, prompt)

        # Check for ESC key (empty input can mean ESC or just Enter)
        if not row_input:
            return

        try:
            row_idx = int(row_input) - 1
            if 0 <= row_idx < len(current_data):
                break  # Valid input, exit loop
            else:
                error_msg = f"Invalid row (must be 1-{len(current_data)})"
        except ValueError:
            error_msg = "Please enter a number"

    # Delete the alias
    if unique_mode:
        row = unique_rows[row_idx]
        key = per_entry_key_unique(row["port"])
        port_info = f"port {row['port']}"
    else:
        entry = detail_entries[row_idx]
        key = per_entry_key_detail(entry)
        port_info = f"{entry.proc} (PID {entry.pid}) on port {entry.port}"

    if key in aliases["per_entry"]:
        old_alias = aliases["per_entry"][key]
        del aliases["per_entry"][key]
        save_aliases(aliases)
        show_message(screen, f"âœ“ Alias '{old_alias}' deleted for {port_info}")
    else:
        show_message(screen, f"âœ“ No alias found for {port_info}")

def handle_process_alias(
    screen,
    unique_mode: bool,
    detail_entries: List[PortEntry],
    unique_rows: List[Dict[str, Any]],
    aliases: Dict[str, Dict[str, str]]
) -> None:
    """Handle setting/editing per-process aliases."""
    proc_name, _ = choose_proc_for_alias(screen, unique_mode, detail_entries, unique_rows)
    if not proc_name:
        return

    current_alias = aliases["per_proc"].get(proc_name) or BUILTIN_FRIENDLY.get(proc_name, "")
    prompt = f"Alias for process '{proc_name}' (max {MAX_ALIAS_LENGTH} chars) [{current_alias}]: " if current_alias else f"Alias for process '{proc_name}' (max {MAX_ALIAS_LENGTH} chars): "

    new_alias = get_user_input(screen, prompt)
    if new_alias:
        aliases["per_proc"][proc_name] = new_alias
        save_aliases(aliases)
        show_message(screen, f"âœ“ Process alias '{new_alias}' saved for '{proc_name}'")
    elif current_alias:
        show_message(screen, f"âœ“ Keeping existing alias '{current_alias}' for '{proc_name}'")
    else:
        show_message(screen, f"âœ“ No alias set for '{proc_name}'")

# =========================
# Entry Point
# =========================
def check_dependencies() -> None:
    """Check that required system dependencies are available."""
    if not shutil.which("lsof"):
        print("Error: lsof not found. Install with: brew install lsof (macOS) or apt install lsof (Linux)")
        raise SystemExit(1)

def show_version() -> None:
    """Show version information."""
    print(f"Ports Manager v{VERSION}")
    print(f"Repository: https://github.com/{GITHUB_REPO}")
    print("Copyright (c) 2024-2025 Adar Bahar")  # cspell:disable-line
    print("Licensed under MIT License")

def main_with_update_check(screen) -> None:
    """Wrapper for main that includes update checking."""
    # Skip update check if --no-update flag is present
    if "--no-update" in sys.argv:
        return main_without_update_check(screen)
    return main(screen)

def main_without_update_check(screen) -> None:
    """Main function without update checking."""
    initialize_curses(screen)

    # Application state
    refresh_secs = REFRESH_SECS_DEFAULT
    only_listen = True
    show_docker_only = True
    unique_mode = True
    last_refresh = 0.0
    last_key_time = 0.0  # For debouncing rapid key presses
    key_debounce_delay = 0.1  # Minimum time between key actions

    # Load aliases
    aliases = load_aliases()

    # Data storage
    detail_entries: List[PortEntry] = []
    unique_rows: List[Dict[str, Any]] = []

    # Main application loop (same as main() but without update check)
    while True:
        current_time = time.time()

        # Refresh data if needed
        if current_time - last_refresh >= refresh_secs:
            # Get lsof data
            lsof_lines = run_lsof(only_listen)
            host_entries = parse_lsof(lsof_lines)

            # Get Docker data
            docker_host_map, docker_only_entries = docker_port_map()

            # Merge and aggregate
            detail_entries = merge_rows(host_entries, docker_host_map, docker_only_entries, show_docker_only)
            unique_rows = aggregate_unique_ports(detail_entries)

            # Redraw screen
            screen.erase()
            draw_header(screen, only_listen, refresh_secs, show_docker_only, unique_mode)

            if unique_mode:
                draw_rows_unique(screen, unique_rows, aliases)
            else:
                draw_rows_detail(screen, detail_entries, aliases)

            draw_footer(screen)
            screen.refresh()
            last_refresh = current_time

        # Handle input with debouncing
        try:
            key = screen.getch()  # cspell:disable-line
        except curses.error:
            key = -1

        # Process key if enough time has passed (debouncing)
        current_time = time.time()
        if key != -1 and (current_time - last_key_time) >= key_debounce_delay:
            last_key_time = current_time

            if key == ord('q'):
                break
            elif key == ord('l'):
                only_listen = not only_listen
                last_refresh = 0
            elif key == ord('d'):
                show_docker_only = not show_docker_only
                last_refresh = 0
            elif key == ord('u'):
                unique_mode = not unique_mode
                last_refresh = 0
            elif key in (ord('+'), ord('=')):
                refresh_secs = max(0.2, refresh_secs - 0.2)
                last_refresh = 0
            elif key in (ord('-'), ord('_')):
                refresh_secs = min(10.0, refresh_secs + 0.2)
                last_refresh = 0
            elif key == ord('a'):
                # Add/Edit per-entry alias
                handle_add_alias(screen, unique_mode, detail_entries, unique_rows, aliases)
                last_refresh = 0
            elif key == ord('x'):
                # Delete per-entry alias
                handle_delete_alias(screen, unique_mode, detail_entries, unique_rows, aliases)
                last_refresh = 0
            elif key == ord('g'):
                # Set/Edit per-process alias
                handle_process_alias(screen, unique_mode, detail_entries, unique_rows, aliases)
                last_refresh = 0
            elif key == ord('?'):
                draw_help(screen)
                last_refresh = 0

        time.sleep(0.05)

if __name__ == "__main__":
    try:
        # Handle command line arguments
        if "--version" in sys.argv or "-v" in sys.argv:
            show_version()
            sys.exit(0)
        elif "--help" in sys.argv or "-h" in sys.argv:
            print("Ports Manager - Monitor network ports and processes")
            print(f"Version: {VERSION}")
            print()
            print("Usage: ports [options]")
            print()
            print("Options:")
            print("  -h, --help       Show this help message")
            print("  -v, --version    Show version information")
            print("  --no-update      Skip automatic update check")
            print()
            print("Controls:")
            print("  q       - quit")
            print("  u       - toggle unique/detail mode")
            print("  l       - toggle LISTEN-only filter")
            print("  d       - toggle docker-only rows")
            print("  + / -   - change refresh speed")
            print("  a       - add/edit alias")
            print("  x       - delete alias")
            print("  g       - set process alias")
            print("  ?       - show help")
            print("  ESC     - cancel current operation")
            sys.exit(0)

        check_dependencies()
        curses.wrapper(main_with_update_check)
    except KeyboardInterrupt:
        print("\nExiting...")
    except Exception as e:
        print(f"Error: {e}")
        raise SystemExit(1)
